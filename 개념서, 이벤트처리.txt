이벤트 처리하기 

React 엘리먼트에서 이벤트를 처리하는 방식은 DOM 엘리먼트에서 이벤트를 처리하는 방식과 매우 유사하다. 

 몇가지 문법 차이는 다음과 같다. 

 React의 이벤트는 소문자 대신 캐멀 케이스를 사용한다. 
 JSX를 사용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다. 

 <button onClick={activated}>
    Active
    </button>

    또 다른 차이점으로 React에서는 false를 반환해도 기본 동작을 방지할 수 없다. 반드시 preventDefault를 명시적으로 호출해야 한다.  예를 들어, 일반 HTML에서 폼을 제출할 때 가지고 있는 기본 동작을 방지하기 위해 다음과 같은 코드를 작성할 수 있다. 

    <form onsubimt="console.log('if you click submit"); return false">
    <button type="submit">submit</button>
    </form>

    React에서는 다음과 같이 작성한다. 

    fucntion Form(){
        function handleSubmit(e){
            e.preventDefault();
            console.log('You clicked submit');
        }
        retrun (
            <form onSubmit={handleSubmit}/>
            <button type="submit">submit</button>
            </form>
        )
    }

    여기서 e는 합성 이벤트이다 React는 W3C에 따라 합성 이벤트를 정의하기 때문에 브라우저 호환성에 대해 걱정할 필요가 없다. React는 브라우저 고유 이벤트와 정확히 동일하게 동작하지는 않는다. 

    React를 사용할 때 DOM 엘리먼트가 생성된 후 리스너를 추가하기 위해 addEventListender를 호출할 필요가 없다. 대신 엘리먼트가 처음 렌더링될 때 리스너를 제공하면 된다. 

    ES6클래스를 사용하여 컴포넌트를 정의할 때, 일반적인 패턴은 이벤트 핸들러를 클래스의 메서드로 만드는 것이다. 예를 들어, 다음 Toggle 컴포넌트는 사용자가 ON, OFF상태를 토글할 수 있는 버튼을 렌더링한다. 


    class Toggle extends React.Component{
        constructor(props){
            super(props);
            this.state={isToggleOn: true};
            this.handleClick = this.handleClick.bind(this);
        }
        handleClick(){
            this.setState(rpevState => ({
                isToggleOn: !prevState.isToggleOn
            }));
        }
        render(){
            return(
                <button onClick={this.handleClick}
                {this.state.isToggleOn ? 'ON':'OFF'}
                </button>
            );
        }
    }
    ReactDOM.render(
        <toggle/>,
        document.getElementById('root')
    );

    JSX콜백 안에서 this의 의미에 대해 주의해야한다. javascript에서 클래스 메서드는 기본적으로 바인딩되어 있지 않는다. this.handleClick을 바인딩하지 않고 onClick에 전달하였다면, 함수가 실제 호출될 때 this는 undefined가 된다. 

    이는 React의 특수한 동작이 아니고 자바스크립트에서 함수가 작동하는 방식의 일부이다. 

    일반적으로 onClick={this.handleClick}과 같이 뒤에()를 사용하지 않고 메서드를 참조할 경우, 해당 메서드를 바인딩 해야 한다. 

    bind를 호출하는 것이 불편하다면 두가지 방법이 있다. 
    퍼블릭 클래스 필드문법 

    class LogginButton extends React.Component{
        //이 문법은 'this'가 handleClick 내에서 바인딩되도록 한다. 
        // 주의 : 이문법은 실험적인 문법이다. 
        handleClick =()=>{
            console.log('this is', this);
        }
    }
    render(){
        return (
            <button onClick={this.handleClick}>
            Click me
            </button>
        );
    }

    클래스 문법을 사용하고 있지 않다면 콜백에 화살표 함수를 사용하는 방법도 있다. 

    render(){
        return (
            <button onClick={()=> this.handleClick()}>
            Click me
            </button>
        )
    }

    이 문법의 문제는 logginButton이 렌더링될 때마다 다른 콜백이 생성된다는 것이다. 대부분의 경우 문제가 되지 않으나 콜백이 하위 컴포넌트에 props로서 전달된다면 그 컴포넌트들은 추가로 다시 렌더링을 수행할 수도 있다. 이러한 성능 문제를 피하고자, 생성자 안에서 바인딩하거나 클래스 필드 문법을 사용하는 것을 권장한다. 


    이벤트 핸ㄷ를러에 인자 전달하기 

    루프 내부에서 이벤트핸들러에 ㅜ가적인 매개변수를 전달하는 것이 일반적이다. 

    <button onClick={(e)=> this.deleteRow(id, e)}>Delete Row</button>
    <button onClick={this.delteRow.bind(this, id)}>Delete Row</button>

    위 두 줄의 결과는 같으며 각각 화살표 함수와 function.portotype.bind를 사용한다. 

    두 경우 모두 React이벤트를 나타내는 e인자가 id 뒤에 두 번째 인자로 전달된다. 화살표함수를 사용하면 명시적으로 인자를 전달해야 하지만 bind를 사용할 경우 추가 인자가 자동으로 전달된다. 