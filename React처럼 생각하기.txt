React로 생각하기 



         디자이너에게 목업과 JSON API를 받았다고 가정하고 어떻게 일을 시작할지 보자


        1단계 : UI를 컴포넌트 계층 구조로 나누기

        모든 컴포넌트의 주변에 박스를 그리고 각각에 이름을 붙인다. 
        어떤 것이 컴포넌트가 되어야 할지 알 수 있을까?
        우리가 새로운 함수나 객체를 만들 때처럼 만들면 된다. 
        한가지 테크닉은 단일 책임 원칙이다. 
        이는 하나의 컴포넌트는 한가지 일을 하게 만드는 것이다. 
        하나의 컴포넌트가 커지게 된다면 이보다 작은 하위 컴포넌트를 만들어 분리 시켜야 한다. 

        주로 JSON데이터를 유저에게 보여주기 때문에 데이터 모델이 적절하게 만들어졌다면 , UI(컴포넌트)가 잘 연결될 것이다. 이는 UI와 데이터 모델이 같은 인포메이션 아키테쳐를 가지는 경향이 있기 때문이다. 각 컴포넌트가 데이터 모델의 한조각을 나타내도록 분리해주자. 

        2단계 : React로 정적인 버전 만들기 

        컴포넌트 계층구조가 만들어졌으니 앱을 실제로 구현해볼 시간이다. 가장 쉬운 방법은 데이터 모델을 가지고 UI를 렌더링은 되지만 아무 동작도 없는 버전을 만들어 보는 것이다. 이처럼 과정을 나누는 것이 좋은데 정적 버전을 만드는 것은 생각은 적게 필요하지만 타이핑은 많이 필요로 하고, 상호작용을 만드는 것은 생각은 많이 해야 하지만 타이핑은 적게 필요로 하기 때문이다. 

        데이터 모델을 렌더링하는 앱ㅂ의 정적 버전을 만들기 위해 다른 컴포넌트를 재사용하는 컴포넌트를 만들고 props를 이용해 데이터를 전달해준다. props는 부모가 자식에게 데이터를 넘겨줄 떄 사용할 수 있는 방법이다. 정적 버전을 만들기 위해 state를 사용하지 않는다. state는 오직 상호작용을 위해, 즉 시간이 지남에 따라 데이터가 바뀌는 것에 사용한다. 우리는 정적 버전을 만들고 있기 때문에 지금은 필요하지 않는다. 

        앱을 만들 때 하향식이나 상향식으로 만들 수 있다.

        계층 구조의 상층부에 있는 컴포넌트부터이거나
        하층부에 있는 컴포넌트부터이거나이다. 

        간단한 예시에서는 하향식으로 만드는 것이 쉽지만 프로젝트가 커지면 상향식으로 만들고 테스트를 작성하면서 개발하기가 더 쉽다. 

        이 단계가 끝나면 데이터 렌더링을 위해 만들어진 재사용 가능한 컴포넌트들의 라이브러리를 가지게 된다. 현재는 앱의 정적 버전이기 때문에 컴포넌트는 render() 메서드만 가지고 있을 것이다. 계층구조의 최상단 컴포넌트는 prop으로 데이터 모델을 받는다. 데이터 모델이 변경되면 REactDOM.render()를 다시 호출해서 UI가 업데이트 된다. UI가 어떻게 업데이트되고 어디에서 변경해야하는지 알수 있다. React의 단방향 데이터 흐름은 모든 것을 모듈화 하고 빠르게 만든다. 


        3단계 : UI state에 대한 최소한의 표현 찾아내기 

        UI를 상호작용하게 만들려면 기반 데이터 모델을 변경할 수 있는 방법이 있어야 한다. 이를 React는 state를 통해 변경한다. 
        
        애플리케이션을 올바르게 만들기 위해서는 애플리케이션에서 필요로 하는 변경 가능한 state의 최소 집합을 생각해보아야 한다. 여기서 핵심은 중복배제원칙이다. 애플리케이션이 필요로 하는 가장 최소한의 state를 찾고 이를 통해 나머지 모든 것들이 필요에 따라 그때그때 계산되도록 만든다. TODO리스트를 만든다고 하면, TODO아이템을 저장하는 배열만 유지하고 TODO 아이템의 개수를 표현하는 state를 별도로 만들지 않는다. TODO 개수를 렌더링해야 한다면 TODO 아이템 배열의 길이를 가져오면 된다. 

        예시 애플리케이션의 데이터들을 생각해보자. 애플리케이션은 다음과 같은 데이터를 가지고 있다.

        1. 제품의 원본 목록
        2. 유저가 입력한 검색어
        3. 체크박스의 값
        4. 필터링 된 제품들의 목록

        각각 살펴보고 어떤 게 state가 되어야 하는 지 살펴보자, 이는 세 가지 질문을 통해 결정할 수 있다. 

        1. 부모로부터 props를 통해 전달되는가? 그러면 확실히 state가 아니다.
        2. 시간이 지나도 변하지 않는가? 그러면 확실히 state가 아니다. 
        3. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가? 그렇다면 state가 아니다. 

        제품의 원본 목록은 props를 통해 전달되므로 state가 아니다. 검색어와 체크박스는 state로 볼 수 있는데 시간이 지남에 따라 변하기도 하면서 다른 것들로부터 계산될 수 없기 때문이다. 그리고 마지막으로 필터링된 목록은 state가 아니다. 제품의 원본 목록과 검색어, 체크박스의 값을 조합해서 계산해낼 수 있기 때문이다. 

        결과적으로 애플리케이션은 다음과 같은 state를 가진다. 

        1. 유저가 입력한 검색어
        2. 체크박스의 값



        4단계 : state가 어디에 있어야 할 지 찾기 

        다음으로 어떤 컴포넌트가 state를 변경하거나 소유할지 찾아야 한다. 

        React는 항상 컴포넌트 계층구조를 따라 아래로 내려가는 단방향 데이터 흐름을 따른다. 어떤 컴포넌트가 어떤 state를 가져야 하는 지 바로 결정하기 어려울 수 있다. 

        애플리케이션이 가지는 각각의 state에 대해서 

        1. state를 기반으로 렌더링하는 모든 컴포넌트를 찾아라
        2. 공통 소유 컴포넌트를 찾아라(계층 구조 내에서 특정 state가 있어야 하는 모든 컴포넌트들의 상위에 있는 하나의 컴포넌트)
        3. 공통 혹은 더 상위에 있는 컴포넌트가 state를 가져야 한다.
        4. state를 소유할 적절한 컴포넌트를 찾지 못하였다면, state를 소유하는 컴포넌트를 하나 만들어서 공통 오너 컴포넌트의 상위 계층에 추가하라 

        이 전략을 적용해보자 

        이 전략을 애플리케이션에 적용해봅시다.

ProductTable은 state에 의존한 상품 리스트의 필터링해야 하고 SearchBar는 검색어와 체크박스의 상태를 표시해주어야 합니다.
공통 소유 컴포넌트는 FilterableProductTable입니다.
의미상으로도 FilterableProductTable이 검색어와 체크박스의 체크 여부를 가지는 것이 타당합니다.
좋습니다. state를 FilterableProductTable에 두기로 했습니다. 먼저 인스턴스 속성인 this.state = {filterText: '', inStockOnly: false} 를 FilterableProductTable의 constructor에 추가하여 애플리케이션의 초기 상태를 반영합니다. 그리고 나서 filterText와 inStockOnly를 ProductTable와 SearchBar에 prop으로 전달합니다. 마지막으로 이 props를 사용하여 ProductTable의 행을 정렬하고 SearchBar의 폼 필드 값을 설정하세요.

이제 애플리케이션의 동작을 볼 수 있습니다. filterText를 "ball"로 설정하고 앱을 새로고침 해보세요. 데이터 테이블이 올바르게 업데이트 된 것을 볼 수 있습니다.






5단계: 역방향 데이터 흐름 추가하기 


    지금까지 계층 구조 아래로 흐르는 props와 state의 함수로써 앱을 만들었다. 이제 다른 방향의 데이터 흐름을 만들어볼 시간이다. 
    
    계층 구조 하단에 있는 폼 컴포넌트에서 FilterableProductTabe의 state를 업데이트 할 수 있어야 한다. 

    React는 전통적인 양ㅂㅇ향 데이터 바인딩과 비교하면 더 많은 타이핑을 필요로 하지만 데이터 흐름을 명시적으로 보이게 만든다. 

    4단계의 예시에서 체크하거나 키보드를 타이핑할 경우 React가 입력을 무시하는 것을 확인할 수 있다. 
    이는 input 태그의 value 송성이 항상 FiterableProductTable에서 전달된 state와 동일하도록 설정했기 때문이다. 

    우리가 원하는 것이 무엇인지 생각해보자

    우리는 사용자가 폼을 변경할 때마다 사용자의 입력을 반영할 수 있도록 state를 업데이트하기 원한다. 컴포넌트는 그 자신의 state만 변경할 수 있기 때문에 FilterableProductTable는 SearchBar에 콜백을 넘겨서 state가 업데이트되어야 할 때마다 호출되도록 할 것이다. 우리는 input에 onChange 이벤트를 사용해서 알림을 받을 수 있따. FilterableProductTable에서 전달된 콜백은 setState()를 호출하고 앱이 업데이트 될 것이다. 