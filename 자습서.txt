React란

React는 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 js라이브러리
컴포넌트라고 불리는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕는다


EX
class shoppingList extends React.Component {
    render(){
        return (
            <div className="shopping_list">
                <h2>Shopping List for {this.props.name}</h2>
                <ul>
                    <li>INstar</li>
                    <li>Facebook</li>
                    <li>Twitter</li>
                </ul>
            </div>
        )
    }
}
컴포넌트를 사용하여 React에게 화면에 표현하고 싶은 것이 무엇인지 알려준다.
데이터가 변경될 때 React는 컴포넌트를 효율적으로 업데이트하고 다시 렌더링한다

shoppingList는 React컴포넌트 클래스 또는 React 컴포넌트 타입이다. 개별 컴포넌트는 
props라는 매개변수를 받아오고 render 함수를 통해 표시할 뷰 계층 구조를 반환

render함수는 화면에서 보고자 하는 내용을 반환
React는 설명을 전달받고 결과를 표시.
특히 reder는 렌더링할 내용을 경량화한 React elemnet를 반환한다. 
다수의 리엑트 개발자는 JSX라는 특수한 문법을 사용하여 쉽게 작성한다. (jsx=html+js)


return React.createElement('div', {className: 'shopping_list'},
React.createElement('h1', /*...h1 children */),
React.createElement('ul', /* ...ul children */)
);


shoppingList 컴포넌트는 <div/>와 <li/> 같은 내각 DOM 컴포넌트만을 렌더링하지만 컴포넌트를 조합하여 커스텀 React컴포넌트를 렌더링하는 것도 가능하다.

React컴포넌트는 캡슐화되어 독립적으로 동작할 수 있다. 이러한 이유로 단순한 컴포넌트를 사용하여 복잡한UI를 구현 가능하다. 

//초기 코드 (기본 틀)
class Square extends React.Component {
    render() {
      return (
        <button className="square">
          {/* TODO */}
        </button>
      );
    }
  }
  
  class Board extends React.Component {
    renderSquare(i) {
      return <Square />;
    }
  
    render() {
      const status = 'Next player: X';
  
      return (
        <div>
          <div className="status">{status}</div>
          <div className="board-row">
            {this.renderSquare(0)}
            {this.renderSquare(1)}
            {this.renderSquare(2)}
          </div>
          <div className="board-row">
            {this.renderSquare(3)}
            {this.renderSquare(4)}
            {this.renderSquare(5)}
          </div>
          <div className="board-row">
            {this.renderSquare(6)}
            {this.renderSquare(7)}
            {this.renderSquare(8)}
          </div>
        </div>
      );
    }
  }
  
  class Game extends React.Component {
    render() {
      return (
        <div className="game">
          <div className="game-board">
            <Board />
          </div>
          <div className="game-info">
            <div>{/* status */}</div>
            <ol>{/* TODO */}</ol>
          </div>
        </div>
      );
    }
  }
  
  // ========================================
  
  ReactDOM.render(
    <Game />,
    document.getElementById('root')
  );
  

  /* 코드를 살펴보면 세 가지 React 컴포넌트가 있다 

  * Square
  * Board
  * Game
  
  square 컴포넌트는 button을 렌더링한다.
  board는 사각형 9개를 렌더링한다
  game 컴포넌트는 게임판을 렌더링하여 나중에 수정할 자리 표시자 값을 가진다

  */

 Props를 통해 데이터 잔달하기

 board 컴포넌트에서 square 컴포넌트로 데이터를 전달

 class Board extends React.Component {
     renderSquare(i){
         return <Square value={i} />;
     }
 }
 값을 표시하기 위해 Square의 render 함수에서 {this.props.value}로 추가
 class Square extends React.Component {
     render(){
         return (
             <button className="square">
                 {this.props.value}
             </button>
         );
     }
 }

 사용자와 상호작용하는 컴포넌트 만들기
 Square 컴포넌트를 클릭하면 X가 체크되도록 하기
 class Square extends React.Component{
     render(){
         return (
             <button className="square" onClick={function() {console.log('click');}}>
             {this.props.value}
             </button>
         )
     }
 }

 다음 단계로 square 컴포넌트를 클릭한 것을 기억하게 만들어 x표시를 채워넣으려 한다.
 이를 위해서 component는 state를 사용한다. 
 React 컴포넌트는 생성자에 this.state를 설정하는 것으로 state를 가질 수 있다.

 class Square extends React.Component {
     constructor(props){
         super(props);
         this.state = {
             value: null,
         };
     }
     render(){
         return (
             <button className="square" onClick={()=> console.log('click')}>
             {this.props.value}
             </button>
         );
     }
 }
****js 클래에서에서 하위 클래스의 생성자를 정의할 때 항상 super로 호출해야 한다. 모든 React 컴포넌트 클래스는 생성자를 가질 때 super(props) 호출 구문부터 작성


이제 square을 클릭할 때 현재 state 값을 표시하기 위해 render 함수를 변경할 것
<button> 태그 안 this.props.value를 this.state.value로 변경
    onClick={...} 이벤트 핸들러를 onClick={()=> this.setState({value: 'X'}) }로 변경
    가독성을 높이기 위해 className과 onClick props를 별도의 줄에 넣는다


    >>>

    class Square extends React.Component {
        constructor(props){
            super(props);
            this.state={
                value: null,
            };
        }
    }
    render(){
        return(
            <button className="square"
            onClick={()=>this.setState({value: 'X'})}>
                {this.state.value}
            </button>
        );
    }

/* 
    개발자 도구 사용 
    chrom과 firfox의 react devtools확장 프로그램을 사용하면 개발자 도구에서 react컴포넌트 트리를 검사할 수 있다.
    codepen에서 도구를 사용하려면
    로그인 > fork버튼 클릭 > change View 클릭하여 debug mode를 선택 > 새탭이 열리면 개발자 도구에서 React 탭을 확인
*/

State 끌어올리기
현재 게임의 state 를 각각의 Square 컴포넌트에서 유지하고 있다. 승자를 확인하기 위해 9개 사각형의 값을 한 곳에 유지할 것이다. 

Board가 각 Square에 Square의 state를 요청해야 한다고 생각할 수 있다.
React에서 이런 접근이 가능하지만 이러한 방식은 버그에 취약하며 리팩토링이 어렵기 떄문에 추천하지 않는다. 

각 Square가 아닌 부모 Board컴포넌트에 게임의 상태를 저장하는 것이 가장 좋은 방법이다.
각 Square에 숫자를 넘겨주었을 때와 같이 Board컴포넌트는 각 square에게 prop을 전달하는 것으로 무엇을 표시할지 알려준다. 

여러개의 자식으로부터 데이터를 모으거나 두 개의 자식 컴포넌트들이 서로 통신하게 하려면
부모 컴포넌트에 공유 state를 정의 해야 한다.
부모 컴포넌트는 props를 사용하여 자식 컴포넌트에 state를 다시 전달할 수 있다. 이것은 자식 컴포넌트들이 서로 또는 부모 컴포넌트와 동기화 하도록 만든다. 

state를 부모 컴포넌트로 끌어올리는 것은 React컴포넌트를 리팩토링할 때 흔히 사용한다!

class Board extends React.Component {
    constructor(props){
        super(props);
        this.state ={
            square: Array(9).fill(null),
        };
    }
    renderSquare(i) {
        return <Square value={i} />;
    }
}

나둥에 board를 채우면 this.state.squares 배열은 아래와 같이 보일 것이다. 
[
    'O', null, 'X',
    'X', 'X', 'O',
    'O', null, null,
]
Board의  renderSquare 함수는 현재 아래와 같은 형태이다.

renderSquare(i){
    retun <Square value={i} />;
}

처음에는 모든 Square에서 0부터 8까지 숫자를 보여주기 위해 Board에서 value prop을 자식으로 전달했다. 
또 다른 이전 단계에서는 숫자를 Square의 자체 state에 따라 "X"로 바꾸었다. 그렇기 때문에 현재 Square는 Board에서 전달한 value prop을 무시하고 있다. 

이제 prop을 전달하는 방법을 다시 사용한다.
각 Square에게 현재 값 ('X', 'O', 또는 null)을 표현하도록 Board를 수정할 것이다. 
Board의 생성자에서 squares 배열을 이미 선언했으며 renderSquare 함수를 아래와 같이 수정 

renderSquare(i){
    return <Square value = {this.state.square[i]} />;
}
Square는 이제 빈 사각형에 'X', 'O', 또는 null인 value prop을 받는다.

다음으로 Square를 클릭할 떄 발생하는 변화가 필요

Board컴포넌트는 어떤 사각형이 채워졌는지를 여부를 관리하므로 Square가 Board를 변경할 방법이 필요하다. 컴포넌트는 자신이 정의한 state에만 접근할 수 있으므로 Square에서 Board의 state를 직접 변경할 수 없다. 

대신에 Board에서 Square로 함수를 전달하고 Square는 사각형을 클릭할 때 함수를 호출할 것이다. 이제 Board의 renderSquare함수를 아래와 같이 변경해준다.  

renderSquare(i){
    return(
        <Square 
            value={this.state.square[i]}
            onClikc={()=>this.hanldeClick(i)}
        />
    );
}

이제 Board에서 Square로 value와 onClick 두 개의 props를 전달하였다. onClick prop은 Square를 클릭하면 호출되는 함수이다. 
Square를 아래와 같이 변경한다. 
 

 *** Square의 render 함수 내부의 this.state.value를 this.props.value로 바꾸어준다.
 *** Square의 render 함수 내부의 this.setState()를 this.props.onClick()으로 바꾸어준다. 
 *** Square는 게임 상태를 유지할 필요가 없기 때문에 constructor를 지워준다. 

 class Square extends React.Component{
     render(){
         return (
             <button
                className="square"
                onClick={()=>this.props.onClick()}
             >
             {this.props.value}
             </button>
         );
     }
 } 

 Square를 클릭하면 Board에서 넘겨받은 onClick함수가 호출된다. 
 이때 일어나는 일을 정리하자 
 
 1. 내장된 DOM <button>컴포넌트에 있는 onClcik prop은 React에게 클릭 이벤트 리스너를 설정하라고 알려준다.  
 2. 버튼을 클릭하면 React는 Square의 render() 함수에 정의된 onClick 이벤트 핸들러를 호출한다.
 3. 이벤트 핸들러는 this.props.onClick()를 호출한다. Square의 onClick prop은 Board에서 정의되었다. 
 4. Board에서 Square로 onClcik={()=> this.handleClcik(i)}를 전달했기 때문에 Square를 클릭하면 Board의 handleClcik(i)를 호출한다 
 5. 아직 handleClcik()를 정의하지 않았기에 에러가 나올 것이다. 

 **
 주의
 DOM <button> 엘리먼트의 onClick 어트리뷰트는 내장된 컴포넌트라는 점에서 React에게 특별한 의미가 있다. Square같은 사용자 정의 컴포넌트의 경우 이름 지정은 자유롭다. 
     Square의 onClick prop이나 Board의 handleClick 함수에는 어떤 이름도 붙일 수 있으며 코드는 동일하게 작동한다. React에서 이벤트를 나타내는 prop에는 on[Event], 이벤트를 처리하는 함수에는 handle[Evnet]를 사용하는 것이 일반적이다. 


이제 handleClick을 Board 클래스에 handleClick을 추가하자

class Board extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            suqare: Array(9).fill(null),
        };
    }
}
handleClick(i){
    const square = this.state.square.slice();
    squares[i] = 'X';
    this.setState({square: squares});
}
renderSquare(i){
    return (
        <Square
         value={this.state.square[i]}
         onClick={()=> this.handleClick(i)}
         />
    );
}
render(){
    const status = 'Next Plater: X';
    return (
        <div>
            <div className="status">{status}</div>
            <div className="board-row">
                {this.renderSquare(0)}
                {this.renderSquare(1)}
                {this.renderSquare(2)}
            </div>
            <div className="board-row">
                {this.renderSquare(3)}
                {this.renderSquare(4)}
                {this.renderSquare(5)}
            </div>
            <div className="board-row">
                {this.renderSquare(6)}
                {this.renderSquare(7)}
                {this.renderSquare(8)}
            </div>
        </div>
    )
}

이제 이전과 마찬가지로 Square를 클릭하여 사각형을 채울 수 있다. 그러나 이제 state가 각 Square 컴포넌트 대신에 Board컴포넌트에 저장된다. Board의 상태가 변화할 때 Square 컴포넌트는 자동으로 렌더링한다. Board컴포넌트의 모든 사각형의 상태를 유지하는 것으로 이후에 승자를 결정하는 것이 가능하다. 

Square컴포넌트가 더 이상 state를 유지하지 않기 때문에 Square 컴포넌트는 Board 컴포넌트에서 값을 받아 클릭될 때 Board 컴포넌트로 정보를 전달한다. 
React용어로 Square컴포넌트는 이제 제어되는 컴포넌트이다. Board는 이들을 완전히 제어한다. 

handleClick에서 .slice()를 호출하는 것으로 기존 배열을 수정하지 않고 squares배열의 복사본을 생성하여 수정하는 것에 주의하자. 왜 squares 배열의 사본을 생성하였는지는 다음에 보자.  


불변성이 왜 중요할까? 

이전 코드 예시에서 기존 배열을 수정하는 것이 아니라 .slice() 연산자를 사용하여 squares배열의 사본 만들기를 하였다. 왜 그렇게 하였을까? 

일반적으로 데이터 변경에는 두 가지 방법이 있다. 첫번째는 데이터의 값을 직접 변경하는 것이다.  두번째는 원하는 변경 값을 가진 새로운 사본으로 데이터를 교체하는 것이다.  

객체 변경을 통해 데이터 수정하기 

var player = {score: 1, name: 'Jeff'};
player.score =2;
//이제 player는 {socre: 2, name: 'jeff'}이다 

객체 변경 없이 데이터 수정하기 
var player = {socre: 3, name: 'tomas'};
var newPlayer = Object.assign({}, player, {score: 5});
//이제 player는 변하지 않았지만 newPlayer는 {score: 5, name: 'tomas'}이다. 
//객체 spread구문을 사용한다면 다음과 같다. 

var newPlayer = {...player, score: 2}

최종 결과는 동일하지만 직접적인 객체 변경이나 기본 데이터의 변경을 하지 않는다면 아래와 같은 몇 가지 이점을 가질 수 있다. 

1. 복잡한 특징들을 단순하게 만든다. 
특정 행동을 취소하고 다시 실행하는 기능은 일반적인 요구사항이다. 직접적인 데이터 변이를 피하는 것이 재사용에 이점을 준다. 

2. 변화를 감지한다. 
객체가 직접적으로 수정되기 때문에 복제가 가능한 객체에서 변화를 감지하는 것은 어렵다. 
감지는 복제가 가능한 객체를 이전 사본과 비교하고 전체 객체 트리를 돌아야 한다. 
불변 객체에서 변화를 감지하는 것은 상당히 쉽다. 참조하고 있는 불변 객체가 이전 객체와 다르다면 객체는 변화 한 것이다. 

3. React에서 다시 렌더링하는 시기를 결정한다. 
불변성의 가장 큰 장점은 react에서 순수 컴포넌트를 만드는데 도움을 준다는 것이다. 
변하지 않는 데이터는 변경이 이루어졌는지 쉽게 판단할 수 있으며 이를 바탕으로 컴포넌트가 다시 렌더링할지를 결정할 수 있다. 

-------------------------------------
함수 컴포넌트로 변환(현시점에서 제일 많이 쓰임)

React에서 함수 컴포넌트는 더 간단하게 컴포넌트를 작성하는 방법이며 
state없이 render 함수만을 가진다. React.Component 를 확장하는 클래스를 정의하는 대신 props를 입력받아서 렌더링할 대상을 반환하는 함수를 작성할 수 있다. 함수 컴포넌트는 클래스로 작성하는 것보다 빠르게 작성할 수 있으며 많은 컴포넌트를 함수 컴포넌트로 표현할 수 있다. 

Square클래스를 바꿔보자

function Square(props){
    return (
        <button className="square" onClick={props.onClick}>
            {props.value}
        </button>
    );
}
모든 this.props를 props로 변경하였다. 

주의
Square를 함수 컴포넌트로 수정했을 때 onClick={()=> this.props.onClick()}을 onClick={props.onClick}로 간결하게 작성한 것이다. 

순서 만들기 

게임판에서 "O"가 표시되지 않는 것을 고쳐보자 

첫 번째 차례를 "X"로 시작하겠다. Board 생성자의 초기 state를 수정하는 것으로 기본값을 설정할 수 있다. 
class Board extends React.Component {
    constructor(props){
        super(props);
        this.state={
            squares: Array(9).fill(null),
            xIsNext: true,
        };
    }
}
플레이어가 수를 둘 때마다 xIsNext(boolean)이 뒤집혀 다음 플레이어가 누군지 결정하고 게임의 state가 저장될 것이다. board의 handleClcik 함수를 수정하여 xIsNext 값을 뒤집어보자. 

handleClick(i){
    const squares = this.state.squares.slice();
    squares[i] = this.state.xIsNext ? 'X': 'O';
    this.setState({
        squares: squares,
        xIsNext: !this.state.xIsNext,
    });
}
이제 "X"와 "O"는 번갈아 나타난다. 

Board의 render안에 있는 "status" 텍스트도 바꿔서 어느 플에이어가 다음 차례인지 알려주자
render(){
    const status = 'Next player : ' +(this.state.xIsNext ? 'X' : 'O');
    return(....)
}
변경사항을 적용한Board컴포넌트를 보자 

class Board extends React.Component {
    constructor(props){
        super(props){
            super(props);
            this.state = {
                suqares: Array(9).fill(null),
                xIsNext: true,
            };
        }
    }
    handleClick(i){
        const squares = this.state.squares.slice();
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            squares: squares,
            xIsNext: !this.state.xIsNext,
        });
    }
}
renderSquare(i){
    return(
        <Square 
            value={this.state.squares[i]}
            onClick={()=>this.handleClick(i)}
        />
        render(){
            const status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
            return(
                <div>
                    <div className="status">{status}</div>
                    <div className="board-row">
                        {this.renderSquare(0)}
                        {this.renderSquare(1)}
                        {this.renderSquare(2)}
                    </div>
                    <div className="board-row">
                        {this.renderSquare(3)}
                        {this.renderSquare(4)}
                        {this.renderSquare(5)}
                    </div>
                    <div className="board-row">
                        {this.renderSquare(6)}
                        {this.renderSquare(7)}
                        {this.renderSquare(8)}
                    </div>
                </div>
            )
        }
    )
}

승자 결정하기

이제 어떤 선수가 다음 차례인지 알려주었으니 승부가 나는 때와 더 이상 둘 곳이 없을 때를 알려주어야 한다. 

function caluculateWinnder(square) {
    const lines = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 9],
        [2, 4, 8],
    ];
    for (let i= 0; i<lines.length; i++){
        const [a,b,c] =lines[i];
        if(squares[a] && squares[a] === squares[b] && squares[a] === squares[c]){
            return squares[a];
        }
    }
    return null;
}
9개 사각형의 배열을 가지고 함수는 승자를 확인하여 적절한 값으로 'X', 'O' 또는 null을 반환한다. 

어떤 플레이어가 우승했는지 확인하기 위해서 Board의 render 함수에서 
caluculateWinnder(squares)를 호출할 것이다. 
한플레이어가 이긴다면 winnder: X 또는 winner: O 같은 문구를 표시할수 있다. 

render(){
    const winnder = calculateWinner(this.state.squares);
    let status;
    if (winner){
        status ='Winner' +winner;
    }else{
        status ='Next Player' + (this.state.xIsNext ? 'X' : 'O');
    }
    return (
        //나머지는 그대로
        )
}

누군가가 승리하거나 Square가 이미 채워졌다면 Board의 handleClick함수가 클릭을 무시하도록 변경

handleClick(i){
    const squares = this.state.squares.slice();
    if(caluculateWinnder(squares)||squares[i]){
        return;
    }
    squares[i] =this.state.xIsNext ? 'X' : 'O';
    this.setState({
        squares: squares,
        xIsNext: !this.state.xIsNext,
    });
}


시간 여행 추가하기 (reset) 
  &&
동작에 대한 기록 저장하기 

suqares배열을 직접 변경했따면 시간여행(reset)을 구현하기 어려웠을 것이다. 
하지만 slice()를 사용해서 매 동작 이후에 squares 배열의 새로운 복사본을 만들었고 이를 불변 객체로 취급했다. 

과거 squares 배열들을 history라는 다른 배열에 저장할 것이다. 
history 배열은 첫 동작부터 마지막 동작까지 모든 게임판의 상태를 표현하고 아래와 같은 형태이다. 

history =[
    //첫 동작이 발생하기 전
    {
        squares: [
            null, null, null,
            null, null, null,
            null, null, null,
        ]
    },
    //첫 동작이 발생한 이후
    {
        squares: [
            null, null, null,
            null, 'X', null,
            null, null, null,
        ]
    },
    //두번째 동작이 발생한 이후
    {
        squares: [
            null, null, null,
            null, 'X', null,
            null, null, 'O'
        ]
    },
    //.....
]
이제 어떤 컴포넌트가 history state를 가질지 결정하자 

다시 State끌어올리자 

이전 동작에 대한 리스트를 보여주려면 최상위 단계의 Game 컴포넌트가 필요하다. history를 이용해야 하기 때문에 최상위 단계 Game 컴포넌트에 history state를 두자

history state를 Game 컴포넌트에 두었기 때문에 자식 Board 컴포넌트에서 squares state를 더이상 사용하지 않아도 된다. Square 컴포넌트에서 Board컴포넌트로 "state"를 끌어올렸던 것처럼 하자

이를 통해 Game 컴포넌트는 Board의 데이터를 완벽히 제어할 수 있으며 history에 저장된 과거의 차례를 Board가 렌더링 할 수 있게 만든다. 

우선 Game 컴포넌트의 생성자 안에 초기 state를 설정하자

class Game extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            history: [{
                squares: Array(9).fill(null),
            }],
            xIsNext: true,
        };
    }
    render(){
        return (
            <div className="game">
                <div className="game-board">
                    <Board />
                </div>
                <div className="game-info">
                    <div>{/*status*/}</div>
                    <ol>{/*TODO*/}</ol>
                </div>
            </div>
        )
    }
}

다음으로 Game 컴포넌트에서 BOard 컴포넌트로 squares와 onClick props를 전달하자 

Board에서 여러 개의 Square에 쓰일 단일 클릭 핸들러를 가졌기 때문에 각 Square의 위치를 onClick 핸들러에게 넘겨주어 어떤 Square를 클릭했는지 표시할 것이다. Board 컴포넌트를 변경하는 순서는 아래와 같다. 

constructor를 Board에서 제거하자
Board의 renderSquare 안의 this.state.squares[i]를 this.props.squares[i]로 바꾼다. 
BOard의 renderSquare 안의 this.handleClick(i)을 this.props.onClick(i)으로 바꾼다. 

이제 Board 컴포넌트는 아래와 같은 형태가 된다. 

class Board extends React.Component{
    handleClick(i){
        const squares = this.state.squares.slice();
        if(calculateWinner(squares)||squares[i]){
            return;
        }
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            suqares: squares,
            xIsNext: !this.state.xIsNext,
        });
    }
    renderSquare(i){
        return (
            <Square 
             value={this.props.squares[i]}
             onClick={()=>this.props.onClick(i)}
             />

        );
    }
    render(){
        const winnder = calculaterWinnder(this.state.squares);
        let status;
        if(winnder){
            status = 'Winner :' + winner;
        }else{
            status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
        }
    return(
        <div>
            <div className="stauts">{status}</div>
            <div className="board-row">
                {this.renderSquare(0)}
                {this.renderSquare(1)}
                {this.renderSquare(2)}
            </div>
            <div className="board-row">
                {this.renderSquare(3)}
                {this.renderSquare(4)}
                {this.renderSquare(5)}
            </div>
            <div className="board-row">
                {this.renderSquare(6)}
                {this.renderSquare(7)}
                {this.renderSquare(8)}
            </div>
        </div>
    )
}
}

Game 컴포넌트의 render  함수를 가장 최근 기록을 사용하도록 업데이트하여 게임의 상태를 확인하고 표시하자 

render(){
    const history = this.state.history;
    const current = history[history.length - 1];
    const winnder = calculateWinner(current.squares);
    let status;
    if (winner){
        status = 'Winner:  ' + winner;
    }else{
        status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');
    }
    return (
        <div className="game">
            <div className="game-board">
                <Board 
                    squares={current.squares}
                    onClick={(i)=> this.handleClick(i)}
                />
            </div>
            <div className="game-info">
                <div>{status}</div>
                <ol>{/*TODO*/}</ol>
            </div>
        </div>
    )
}

Game 컴포넌트가 게임의 상태를 렌더링하기 때문에 Board의 render 함수에서 중복되는 코드를 제거할 수 있다. 리펙토링 이후에 Board의 render 함수는 아래와 같다. 

render() {
    return (
        <div>
            <div className="board-row">
                {this.renderSquare(0)}
                {this.renderSquare(1)}
                {this.renderSquare(2)}
            </div>
            <div className="board-row">
                {this.renderSquare(3)}
                {this.renderSquare(4)}
                {this.renderSquare(5)}
            </div>
            <div className="board-row">
                {this.renderSquare(6)}
                {this.renderSquare(7)}
                {this.renderSquare(8)}
            </div>
        </div>
    )
}

그리고 handleClick 함수를 Board에서 Game 컴포넌트로 이동한다. 
또한 Game 컴포넌트의 state가 다르게 구성되었기에 handleClick을 수정해야 한다. 
Game의 handleClick 함수에서 새로운 기록 목록을 histroy로 연결한다. 

handleClick(i){
    const history = this.state.history;
    const current = history[history.length-1];
    const squares = current.squares.slice();
    if(calculateWinner(squares)||squares[i]){
        return;
    }
    squares[i] = this.state.xIsNext ? 'X' : 'O';
    this.setState({
        history: history.concat([{
            suqares: suqares,
        }]),
        xIsNext: !this.state.xIsNext,
    });
}

주의
배열 Push() 함수와 같이 더 익숙한 방식과 달리 concat() 함수는 기존 배열을 변경하지 않기 때문에 이를 더 권장한다.


현재 시점에서 Board 컴포넌트는 renderSquare와 render 함수만을 필요로 한다. 게임의 상태와 handleClcik 함수는 Game 컴포넌트가 가지고 있어야 한다. 



과거의 이동 표시하기 

과거의 이동을 목록으로 표시하자 
앞서서 React 엘리먼트는 애플리케이션에 전달할 수 있는 클래스형 javascript 객체라는 것을 배웠다. react 엘리먼트 배열을 사용하면 여러 아이템을 렌더링할 수 있다. 
javascript에서 배열은 데이터를 다른 데이터와 함께 맾핑할 때 사용하는 Map()함수를 가지고 있다. 
// const numbers= [1, 2, 3];
// const doubled = numbers.amp(x=> x*2); //[ 2, 4, 6]

map함수를 사용하여 이동 기록을 화면에 표시되는 React버튼 엘리먼트로 맵핑할 수 있으며 과거의 이동으로 돌아가는 버튼 목록을 표시할 수 있다. 
이제 render함수에서 history를 map해보자

render(){
    const histroy = this.state.history;
    const current = histroy[history.length-1];
    const winner = calculateWinner(current.squares);
    const moves = histroy.map((step, move) =>{
        const desc = move ? 'Go to move #' + move : 'Go to game start';
        return (
            <li>
                <button onClick={()=> this.jumpTo(move)}>{desc}</button>
            </li>
        );
    });
    let status;
    if(winner){
        status = 'Winner: ' + winner;
    }else{
        status = 'Next player ' + (this.state.xIsNext ? 'X' : 'O');
    }
    return(
        <div className="game">
            <div className="game-board">
                <Board 
                    squares={current.squares}
                    onClick={(i)=> this.handleClick(i)}
                />
            </div>
            <div className="game-info">
                <div>{status}</div>
                <ol>{moves}</ol>
            </div>
        </div>
    )
}
histroy 배열을 순회하면서 step 변수는 현재 histroy 요소의 값을 참조하며 move는 현재 histroy 요소의 인덱스를 참조한다. 지금은 move에만 집중하므로 step은 다른 곳에 할당되진 않는다. 

게임 기록의 각각 이동마다 버튼 <button>을 포함하는 리스트 아이템<li>를 생성한다. 버튼은 this.jumpTo()함수를 호출하는 onClick 핸들러를 가지고 있다. 아직은 jumpTo() 함수를 구현하지 않았다. 
    따라서 다음과 같은 err를 마주한다. 
    배열이나 이터레이터의 자식들은 고유의 "Key" prop을 가지고 있어야 합니다. "Game"의 render 함수를 확인해라. 

    위 경고가 무엇을 의미할까? 

    key 선택하기 

    리스트를 렌더링할 때 React는 렌더링하는 리스트 아이템에 대한 정보를 저장한다. 리스트를 업데이트 할 때 React는 무엇이 변했는 지 결정해야 한다. 리스트의 아이템들은 추가, 제거, 재배열, 업데이트 될 수 있다. 

    아래의 코드가

    <li>Alexa: 7 tasks left</li>
    <li>Ben: 5 tasks left</li>
    다음과 같이 변한다고 상상해 보자.

    <li>Ben: 9 tasks left</li>
    <li>Claudia: 8 tasks left</li>
    <li>Alexa: 5 tasks left</li>

    사람의 눈에는 task 개수가 업데이트 되었을 뿐만 아니라 Alexa와 Ben의 순서가 바뀌고 Claudia가 두 사람 사이에 추가 되었다고 생각할 거다. 그러나 React는 프로그램이다. 사람이 아니다. 

    그렇기 때문에 리스트 아이템에 key prop을 지정하여 각 아이템이 다른 아이템들과 다르다는 것을 알려주어야 한다!

    키를 지정하는 한 가지 방법은 문자를 사용하는 것. 데이터베이스에서 데이터를 불러와서 표시한다면 데이터베이스 ID가 키로 사용될 수 있다. 

    <li key={user.id}>{user.name}:{user.taskCount}tasks left</li>

    목록을 다시 렌더링하면 React는 각 리스트 아이템의 키를 가져가며 이전 리스트 아이템에서 일치하는 키를 탐색한다. 현재 리스트에서 이전에 존재하지 않는 키를 가지고 있다면 React는 새로운 컴포넌트를 생성한다. 현재 리스트가 이전 리스트에 존재했던 키를 가지고 있지 않다면 React는 그 키를 가진 컴포넌트를 제거한다. 두 키가 일치한다면 해당 구성요소는 이동한다. 키는 각 컴포넌를 구별할 수 있도록 하여 React에게 다시 렌더링할 때 state를 유지할 수 있게 한다. 컴포넌트의 키가 변한다면 컴포넌트는 제거되고 새로운 state와 함께 다시 생성된다. 
    >> key를 확인하고 없다면 react는 새로운 컴포넌트 생성한다. 
    >> 현재 리스트에 이전 리스트에 존재했던 키를 가지고 있지 않다면 React는 그 키를 가진 컴포넌트를 제거
    >> 두 키가 일치한다면 해당 구성요소는 이동한다. 
    >> 키는 각 컴포넌트를 구별할 수 있도록 한다. 따라서 react에게 다시 렌더링할 때 state를 유지할 수 있게 한다. 
    >> 컴포넌트의 키가 변한다면 컴포넌트는 제거되고 새로운 state와 함께 다시 생성된다. 

    React에서 key는 심화 기능인 ref와 동일하게 특별하고 미리 지정된 prop이다. 엘리먼트가 생성되면 React는 key 속성을 추출하여 반환되는 엘리먼트에 직접 키를 저장한다. key가 props에 속하는 것처럼 보이지만 this.props.key로 참조할 수 없다. react는 자동으로 key를 어떤 컴포넌트를 업데이트 할 지 판단하는 데 사용한다. 컴포넌트는 key를 조회할 수 없다. 

    동적인 리스트를 만들 때마다 적절한 키를 할당할 것을 추천한다. 

    키가 지정되지 앟는 경우 React는 경고를 표시하며 배열의 인덱스를 기본 키로 사용한다. 
    배열의 인덱스를 키로 사용하는 것은 리스트 아이템 순서를 바꾸거나 아이템을 추가/제거 할 때 문제가 된다. 명시적으로 key={i}를 전달하면 경고가 나타나지는 않지만 동일한 문제를 일으키기 때문에 대부분의 경우에 적합하지 않다. 

    키는 전역에서 고유할 필요는 없으며 컴포넌트와 관련 아이템 사이에서는 고유한 값을 가져야 한다. 




    리셋 구현하기

    게임의 기록에서 과거의 이동 정보는 이동의 순차적인 숫자를 고유한 ID로 가졌다. 이동은 순서가 바뀌거나 삭제되거나 중간에 삽입될 수 없기 때문에 이동의 인덱스를 키로 사용해도 안전하다. 

    Game 컴포넌트의 render 함수 안에서 <li key={move}>로 키를 추가하려면 React의 키에 대한 경고가 사라질 것이다. 

    const moves = history.map((step, move)=>{
        const desc = move ? 'Go to move #' +move : 'Go to game start';
        return (
            <li key={move}>
                <button onClick={()=> this.jumpTo(move)}>{desc}</button>
            </li>
        );
    });

    jumpTo를 정의하기 전에 Game 컴포넌트의 state에 stepNumber를 추가하여 현재 진행 중인 단계를 표시하자 

    class Game extends React.Component{
        constructor(props){
            super(props);
            this.state = {
                histroy: [{
                    squares: Array(9).fill(null),
                }],
                stepNumber: 0,
                xIsNext: true,
            };
        }
    }
    다음으로 Game 의 stepNumber를 업데이트 하기 위해 jumpTo를 정의하자 또한 stepNumber가 짝수일 때마다 xIsNExt를  true로 설정
    hendleClick(i){
        //이 함수는 변하지 않는다. 
    }
    jumpTo(step){
        this.setState({
            stepNumber: step,
            xIsNext: (step %2)===0,
        });
        reunder(){
            //이 함수는 변하지 않는다. 
        }
    }
    jumpTo 메소드에서 state의 history 속성을 업데이트 하지 않았음을 주목하자. 상태 업데이트가 병합되거나 더 간단한 단어로 React는 나머지 상태를 그대로 두고 setState메서드에 언급된 속성만 업데이트하기 때무이다. 


    이제 사각형을 클릭할 때 마다 실행되는 Game의 handleClick 함수에 몇 가지 변화를 줄 것이다. 

    stepNumber state는 현재 사용자에게 표시되는 이동을 반영한다. 
    this.setState의 인자로 stepNumber: history.lenght를 추가하여 stepNumber를 업데이트 한다. 이를 통해 새로운 이동이 생성된 후에 이동이 그대로 남아있는 것을 방지한다. 

    또한 this.state.history를 this.state.history.slice(0, this.state.stepNumber +1)로 교체한다. 
    그결과로 시간을 거슬러 올라가고,    그 시점에서 새로운 이동을 발생한다면 이제는 맞지 않게 된 모든 "미래"의 기록을 날려버린다. 

    handleClick(i){
        const history = this.state.history.slice(0, this.state.stepNumber +1);
        const current = histroy[histroy.lenght -1];
        const squares = current.squares.slice();
        if (caluculateWinnder(squares) || squares[i]){
            return;
        }
        squares[i] = this.state.xIsNext ? 'X' : 'O';
        this.setState({
            history: history.concat([{
                squares: squares
            }]),
            stepNumber: history.length,
            xIsNext: !this.state.xIsNext,
        });
    }

    Game 컴포넌트의 render 함수를 수정하여 항상 마지막 이동을 렌더링하는 대신 stepNumber에 맞는 현재 선택된 이동을 렌더링하자 
    

    render(){
        const history = this.state.history;
        const current = history[this.state.stepNumber];
        const winner = calculateWinner(current.squares);
    }